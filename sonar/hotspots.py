#
# sonar-tools
# Copyright (C) 2022 Olivier Korach
# mailto:olivier.korach AT gmail DOT com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""Abstraction of the SonarQube "hotspot" concept"""

import json
import requests.utils
import sonar.utilities as util
import sonar.issue_changelog as changelog
from sonar import env, projects, findings


_JSON_FIELDS_REMAPPED = (
    ('pull_request', 'pullRequest'),
    ('_comments', 'comments')
)

_JSON_FIELDS_PRIVATE = ('endpoint', 'id', '_json', '_changelog', 'assignee', 'hash', 'sonarqube',
    'creation_date', 'modification_date', '_debt', 'component', 'language', 'resolution')

_CSV_FIELDS = ('key', 'rule', 'type', 'severity', 'status', 'createdAt', 'updatedAt', 'projectKey', 'projectName',
            'branch', 'pullRequest', 'file', 'line', 'effort', 'message')

_HOTSPOTS = {}


class TooManyHotspotsError(Exception):
    def __init__(self, nbr_issues, message):
        super().__init__()
        self.nbr_issues = nbr_issues
        self.message = message

class Hotspot(findings.Finding):

    def __init__(self, key, endpoint, data=None, from_export=False):
        super().__init__(key, endpoint, data, from_export)
        self.vulnerabilityProbability = None
        self.securityCategory = None
        self.type = 'SECURITY_HOTSPOT'
        self._details = None
        if data is not None:
            self.category = data['securityCategory']
            self.vulnerabilityProbability = data['vulnerabilityProbability']
        _HOTSPOTS[self.uuid()] = self

    def __str__(self):
        return f"Hotspot key '{self.key}'"

    def url(self):
        branch = ''
        if self.branch is not None:
            branch = f'branch={requests.utils.quote(self.branch)}&'
        elif self.pull_request is not None:
            branch = f'pullRequest={requests.utils.quote(self.pull_request)}&'
        return f'{self.endpoint.url}/security_hotspots?{branch}id={self.projectKey}&hotspots={self.key}'

    def to_json(self):
        data = super().to_json()
        data['url'] = self.url()
        return data

    def __mark_as(self, resolution, comment=None):
        params = {'hotspot': self.key, 'status': 'REVIEWED', 'resolution': resolution}
        if comment is not None:
            params['comment'] = comment
        return self.post('hotspots/change_status', params=params)

    def mark_as_safe(self):
        return self.__mark_as('SAFE')

    def mark_as_fixed(self):
        return self.__mark_as('FIXED')

    def mark_as_to_review(self):
        params = {'hotspot': self.key, 'status': 'TO_REVIEW'}
        return self.post('hotspots/change_status', params=params)

    def reopen(self):
        self.mark_as_to_review()

    def add_comment(self, comment):
        params = {'hotspot': self.key, 'comment': comment}
        return self.post('hotspots/add_comment', params=params)

    def assign(self, assignee, comment=None):
        params = {'hotspot': self.key, 'assignee': assignee}
        if comment is not None:
            params['comment'] = comment
        return self.post('hotspots/assign', params=params)

    def changelog(self, cache=True):
        if self._changelog is not None and cache:
            return self._changelog
        resp = self.get('hotspots/show', {'issue': self.key, 'format': 'json'})
        self._details = json.loads(resp.text)
        util.json_dump_debug(self._details, f"{str(self)} Details = ")
        self._changelog = {}
        seq = 1
        for l in self._details['changelog']:
            d = changelog.Changelog(l)
            if d.is_technical_change():
                # Skip automatic changelog events generated by SonarSource itself
                util.logger.debug('Changelog is a technical change: %s', str(d))
                continue
            util.json_dump_debug(l, "Changelog item Changelog ADDED = ")
            seq += 1
            self._changelog[f"{d.date()}_{seq:03d}"] = d
        return self._changelog

    def comments(self, cache=True):
        if self._comments is not None and cache:
            return self._comments
        resp = self.get('hotspots/show', {'issue': self.key, 'format': 'json'})
        self._details = json.loads(resp.text)
        util.json_dump_debug(self._details, f"{str(self)} Details = ")
        self._comments = {}
        seq = 0
        for c in self._details['comments']:
            seq += 1
            self._comments[f"{c['createdAt']}_{seq:03d}"] = {'date': c['createdAt'], 'event': 'comment',
                'value': c['markdown'], 'user': c['login'], 'userName': c['login'], 'commentKey': c['key']}
        return self._comments

    def modifiers(self):
        """Returns list of users that modified the issue."""
        item_list = []
        for c in self.changelog().values():
            util.logger.debug("Checking author of changelog %s", str(c))
            author = c.author()
            if author is not None and author not in item_list:
                item_list.append(author)
        return item_list

    def commenters(self):
        """Returns list of users that commented the issue."""
        return util.unique_dict_field(self.comments(), 'user')

    def modifiers_and_commenters(self):
        modif = self.modifiers()
        for c in self.commenters():
            if c not in modif:
                modif.append(c)
        return modif

    def modifiers_excluding_service_users(self, service_users):
        mods = []
        for u in self.modifiers():
            if u not in service_users:
                mods.append(u)
        return mods

    def strictly_identical_to(self, another_issue, ignore_component=False):
        return (
            self.rule == another_issue.rule and
            self.hash == another_issue.hash and
            self.message == another_issue.message and
            self.file() == another_issue.file() and
            (self.component == another_issue.component or ignore_component)
        )

    def almost_identical_to(self, another_issue, ignore_component=False, **kwargs):
        if self.rule != another_issue.rule or self.hash != another_issue.hash:
            return False
        score = 0
        if self.message == another_issue.message or kwargs.get('ignore_message', False):
            score += 2
        if self.file() == another_issue.file():
            score += 2
        if self.line == another_issue.line or kwargs.get('ignore_line', False):
            score += 1
        if self.component == another_issue.component or ignore_component:
            score += 1
        if self.author == another_issue.author or kwargs.get('ignore_author', False):
            score += 1
        if self.type == another_issue.type or kwargs.get('ignore_type', False):
            score += 1
        if self.severity == another_issue.severity or kwargs.get('ignore_severity', False):
            score += 1
        # Need at least 7 / 9 to match
        return score >= 7


def search_by_project(project_key, endpoint=None, branch=None, pull_request=None):
    new_params = {}
    if project_key is None:
        key_list = projects.search(endpoint).keys()
    else:
        key_list = util.csv_to_list(project_key)
    hotspots = {}
    if branch is not None:
        new_params['branch'] = branch
        key_list = [key_list[0]]
    elif pull_request is not None:
        new_params['pullRequest'] = pull_request
        key_list = [key_list[0]]

    for k in key_list:
        util.logger.info("Hotspots search by project %s branch %s PR %s", k, branch, pull_request)
        new_params['projectKey'] = k
        project_hotspots = search(endpoint=endpoint, params=new_params)
        util.logger.info("Project %s branch %s has %d hotspots", k, str(branch), len(project_hotspots))
        hotspots.update(project_hotspots)
    return hotspots


def search(endpoint=None, page=None, params=None):
    if params is None:
        new_params = {}
    else:
        new_params = params.copy()
    new_params['ps'] = 500
    p = 1
    hotspots = {}
    while True:
        if page is None:
            new_params['p'] = p
        else:
            new_params['p'] = page
        resp = env.get('hotspots/search', params=new_params, ctxt=endpoint)
        data = json.loads(resp.text)
        nbr_hotspots = data['paging']['total']
        nbr_pages = (nbr_hotspots + 499) // 500
        util.logger.debug("Number of issues: %d - Page: %d/%d", nbr_hotspots, new_params['p'], nbr_pages)
        if page is None and nbr_hotspots > 10000:
            raise TooManyHotspotsError(nbr_hotspots,
                                     f'{nbr_hotspots} hotpots returned by api/hotspots/search, '
                                     'this is more than the max 10000 possible')

        for i in data['hotspots']:
            hotspots[i['key']] = get_object(i['key'], endpoint=endpoint, data=i)
        if page is not None or p >= nbr_pages:
            break
        p += 1
    return hotspots


def get_object(key, data=None, endpoint=None, from_export=False):
    if key not in _HOTSPOTS:
        _ = Hotspot(key=key, data=data, endpoint=endpoint, from_export=from_export)
    return _HOTSPOTS[key]
